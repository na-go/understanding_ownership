# 所有権について


## 所有権規則
- Rustの各値は, **所有者**と呼ばれる変数と対応している.
- いかなる時でも所有者は1つである.
- 所有者がスコープから外れたら値は破棄される.

## 変数スコープ
- 変数がスコープに入ると有効になる
- スコープを抜けるまでずっと有効

## String型
データ型で議論した方はすべて**スタックに保管**.
- スコープが終わるとスタックから取り除かれる. 

ここからは**ヒープに保管されるデータ型**の話をする.
- 例としてStiring型を使う

注目しているのはString型の所有権.
```rust
let mut s = "a";
s.push_str(" b");
```
みたいなことは出来ない.

何故なら, この`s`は
| 0 | 1 |・・・|
| ---- | ---- | ---- |
| 確保したよ！`"a"` |確保してないよ | ・・・|
みたいな感じで0番の場所しかメモリを確保してない.
なのでそこにプラスで文字列を足そうとすると追加でメモリを必要とする
Rustはメモリ管理ちゃんとやってるからそういうのはだめーになってるっぽい. もしやるなら
```rust
let mut s = String::from("a");
s.push_str(" b");
```
みたいにしないといけない.

これはStringと明記しないと可変でメモリを確保してくれないからかも.

- この標準ライブラリや自分で生成するほかの複雑なデータ型にも適用される.

### 疑問
可変(多め)に確保したい気持ちがあるなら
```rust
let mut s = String::from("a");
```
って宣言するのはわかるけど
```rust
let s = String::from("a");
```
って宣言するうれしさがわからない.

## メモリと確保
文字列リテラルの場合、中身はコンパイルした時点でわかっている.
→ テキストは最終的なバイナリファイルに直接ハードコードされる.
→ 高速で効率的になる.
→ But 文字列リテラルが不変だから起こること
- [x] コンパイルしたタイミングでサイズが分からなかったり, 実行に合わせてサイズが可変なテキスト用に一塊のメモリをバイナリに保存しておくことは不可能.

String型では、可変かつ伸長可能なテキストをさぽーとするために
- [x] コンパイル時には不明な量のメモリをヒープに確保して内容を保持する
1. メモリは実行時にOSに要求される
2. String型を使用し終えたら、OSにこのメモリを変換する方法が必要である.

1.は`String::from`の部分が該当する(`allocate`と呼ばれるもの). 2.に関してだがガベージコレクタ付きの言語では良いタイミングで勝手にやってくれるので考慮しなくてよい(`free`と呼ばれるもの).

### 変数とデータの相互作用法:move
- スタックはコピーして代入ができる
```rust
let x = 4;
let y = x;
```
- ヒープは出来ない.
  - もしした場合, 最初に用意した変数は代入先の変数に移動したと捉えられるため, 最初に用意した変数は以後使えない.
```rust
let s1 = "hello";
let s2 = s1;
```
上の例なら`println!("{}",s2);`は`hello`を出力するが, `println!("{}",s1);`は`s1`が移動して使えなくなっているので怒られが発生する.

### 変数とデータの相互作用法:clone

**どうしても**String型のヒープデータをdeepcopyが必要なら`clone`メソッドを使えば出来る. けどあんまりしないほうが良いよね（って文脈から思った)

### スタックのみのデータ:copy
以下のようなスタックに保持される型は代入後も古い変数が使える.
- 整数型
- 論理値型
- 浮動小数点数
- 文字型
- タプル、但し上記のcopyの型だけを含む場合

## 所有権と関数

変数が引数としてある戻り値の無い関数に入った時点で所有権は関数内に移動する.
したがってその関数以降では引数として使った変数は所有権を失うので使えなくなる

```rust
fn main() {
    let s = String::from("hello");  // sがスコープに入る

    takes_ownership(s);             // sの値が関数にムーブされ...
                                    // ... ここではもう有効ではない

    let x = 5;                      // xがスコープに入る

    makes_copy(x);                  // xも関数にムーブされるが、
                                    // i32はCopyなので、この後にxを使っても
                                    // 大丈夫

}   // ここでxがスコープを抜け、sもスコープを抜ける。ただし、
    //sの値はムーブされているので、何も特別なことは起こらない。

fn takes_ownership(some_string: String) { // some_stringがスコープに入る。
    println!("{}", some_string);
}   // ここでsome_stringがスコープを抜け、`drop`が呼ばれる。
    //後ろ盾してたメモリが解放される。

fn makes_copy(some_integer: i32) { // some_integerがスコープに入る
    println!("{}", some_integer);
} // ここでsome_integerがスコープを抜ける。何も特別なことはない。
```

### 戻り値とスコープ

値を返してもスコープは移動する.

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownershipは、戻り値をs1に
                                        // ムーブする

    let s2 = String::from("hello");     // s2がスコープに入る

    let s3 = takes_and_gives_back(s2);  // s2はtakes_and_gives_backにムーブされ
                                        // 戻り値もs3にムーブされる
} // ここで、s3はスコープを抜け、ドロップされる。s2もスコープを抜けるが、ムーブされているので、
  // 何も起きない。s1もスコープを抜け、ドロップされる。

fn gives_ownership() -> String {             // gives_ownershipは、戻り値を
                                             // 呼び出した関数にムーブする

    let some_string = String::from("hello"); // some_stringがスコープに入る

    some_string                              // some_stringが返され、呼び出し元関数に
                                             // ムーブされる
}

// takes_and_gives_backは、Stringを一つ受け取り、返す。
fn takes_and_gives_back(a_string: String) -> String { // a_stringがスコープに入る。

    a_string  // a_stringが返され、呼び出し元関数にムーブされる
}
```